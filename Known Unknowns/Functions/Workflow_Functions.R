

library(jsonlite)
library(data.table)



# Function to create a list of the default parameters that are (likely) to remain stable across model runs. 
get_default_params = function() {
  params = list()
  params["cohort_size"] = 1000
  params["lesion_formation_rate"] = 0.05
  params["formation_window_opens"] = 0
  params["formation_window_closes"] = 10
  params[["mortality_regime"]] = CoaleDemenyWestF5
  params["mortality_risk_type"] = "proportional"
  params["relative_mortality_risk"] = 1
  return(params)
}



params = get_default_params()

### Function to run the model a single time, creating a named output directory and a generating a random seed.
# This function creates an 'output directory' folder and inside it, it saves
# the random seed (.csv file)
# the list of parameters used in the model (.json file)
# the data frame of imaginary people and their language data generated by the model (.csv file)
run_model_single = function(params, output_directory, seed = NA) {
  
  #Create a uniquely named output directory to store the output from this model run. 
  if (dir.exists(output_directory)) {
    print("Warning: output directory already exists! Skipping simulation to avoid overwriting data.")
    return()
  } else {
    dir.create(output_directory, recursive=TRUE)
  }
  
  #If no seed is set, set a unique random seed
  if (is.na(seed)) {
    seed = as.numeric(format(Sys.time(), "%OS6"))*1000000 #choose milliseconds of current time as seed
  }
  set.seed(seed)
  # in the output directory for this model run, keep a record of the random seed used so that the exact output of this run can be replicated. 
  write(seed, file = file.path(output_directory, "seed.csv"))
  
  
  #Write input parameters to output_directory
  write(toJSON(params, pretty=TRUE), file=file.path(output_directory, "params_used.json"))
  
  #Run model
  output = do.call(Simulate_Cemetery, params)

  #Write model output
  write.csv(output$individual_outcomes, file=file.path(output_directory, "sim_cemetery.csv"), row.names=FALSE)
  write.csv(output$survivors, file=file.path(output_directory, "sim_survivors.csv"), row.names=FALSE)
  
  
  #For convenience, also return output here
  return(output)
}



 # run_model_single(params = get_default_params(), output_directory = "./Theoretical Age Distributions of Skeletal Lesions/Developmental Windows/Output/Test")







### Function to systematically run and save multiple runs of the model with the same parameter values.
# User designates the root output directory, parameter values, and the number of runs (numreps).
# Each run will be saved in its own named folder, which will contain the files created by run_model_single() described above
run_model_reps = function(params, root_output_directory, numreps=10) {
  for (rep in 1:numreps) {
    output_directory = file.path(root_output_directory, paste0("rep=", rep))
    run_model_single(params, output_directory)
  }
}







### Function to perform a sweep over specified values of a single parameter, holding all other values constant.
# This function wraps around the previous two functions. It produces a folder for each unique set of parameter values, 
# named for the parameter being swept, and its value in this set of runs. Inside the folder is a folder for each run (rep), containing the value of the random seed, the .json file of parameter values, and the output of the model run. 

#targetParam: the name of the parameter you want to sweep over
#targetParamValues: the values you want to sweep over (list or vector)
run_model_sweep = function(base_params, root_output_directory, target_param, target_param_values, numreps=10) {
  for (iVal in 1:length(target_param_values)) {
    # for each unique value of the target parameter, name the folder to hold all runs of the model that uses this parameter value. 
    param_set_output_directory = file.path(root_output_directory, paste0(target_param, "=", target_param_values[iVal]))
    params = copy(base_params)
    # overwrite the default parameter value with the current value of the target parameter
    params[target_param] = target_param_values[iVal]
    
    run_model_reps(params, param_set_output_directory, numreps=numreps)
  }
  
  sweep_data = list()
  sweep_data["target_param"] = target_param
  sweep_data[["target_param_values"]] = target_param_values
  write(toJSON(sweep_data, pretty=TRUE), file=file.path(root_output_directory, "sweep_data.json"))
}








### Function to read in the data generated from a parameter sweep
read_model_sweep = function(root_output_directory, target_param, target_param_values) {
  sweep_results = list()
  
  # for each value in the parameter being swept
  for (param_value in target_param_values) {
    param_dir = file.path(root_output_directory, paste0(target_param,"=", param_value)) # identify the directory where the output for that scenario is stored
    rep_dirs = list.dirs(param_dir, recursive = FALSE, full.names = TRUE) # identify the file paths for all the iterations/runs of that scenario
    
    # extract the output .csv file from each run
    rep_outputs = lapply(rep_dirs, function(rep_dir) {
      output_file = file.path(rep_dir, "sim_cemetery.csv")
      if (file.exists(output_file)) {
        return(read_csv(output_file))
      } else {
        print("file does not exist")
        return(NULL)
      }
    })
    
    # and save it as an entry in the sweep_results list, named with the target parameter value for this set of runs. 
    sweep_results[[paste0(target_param,"=",param_value)]] = rep_outputs
  }
  
  # return a list of lists: one for each value of the target parameter, containing a list of model output data frames from the output.csv files
  return(sweep_results)
}









# Example: How to use all these functions 
# params = get_default_params()
# single_test = run_model_single(params, output_directory = "output_directory")
# run_model_reps(params, "model_output/test_run", numreps=2)
# run_model_sweep(base_params = params, root_output_directory = "./Model 5.0/model_output/test_sweep", target_param = "prop_of_intra_household_interactions",
#                 target_param_values = c(0.25, 0.5, 0.75), numreps = 2)








# Generate the name of the output directory as a function of the parameter values for this set of model runs.
generate_output_directory <- function(params) {
  mortality_regime_number <- gregexpr("[0-9]+", params[["mortality_regime"]]$name)
  mortality_regime_abbrev <- paste0("CDW", regmatches(params[["mortality_regime"]]$name, mortality_regime_number))
  paste0("./Known Unknowns/Output/RMR=", params[["relative_mortality_risk"]], "/", mortality_regime_abbrev)
}


#### DATA RESHAPING FUNCTIONS ####
# Convert list object with cemetery data output from individual reps and scenarios into a single data frame with output from the parameter sweep
data_to_data_frame <- function(cemetery_data_list, target_param_values){
  worlds <- data.frame()
  for(scenario in seq_along(target_param_values)){
    for(rep in seq_along(cemetery_data_list[[scenario]])){
      cemetery_data_list[[scenario]][[rep]]$rep <- rep # Count the iterations
    }
    out <- do.call("rbind", cemetery_data_list[[scenario]]) # Compile the list of iterated runs into a single data frame
    out$lesion_formation_rate <- target_param_values[scenario]  # Add mortality regime name
    worlds <- bind_rows(worlds, out)  # Combine all scenarios across the parameter sweep into a single data frame
    worlds$mortality <- "CDW3"  # Add mortality regime name
  }
  return(worlds)
}

# Function to calculate percent of individuals at each age in the cemetery with skeletal lesions
lesions_to_percents <- function(cemetery_df, group_vars) {
  
  # Define age interval labels and their midpoints
  age_lookup <- data.frame(
    Age_Interval = factor(
      c("0-1", "2-5", "6-9", "10-14", "15-19",
        "20-29", "30-39", "40-49", "50-59", "60+"),
      levels = c("0-1", "2-5", "6-9", "10-14", "15-19",
                 "20-29", "30-39", "40-49", "50-59", "60+")
    ),
    interval_midpoint = c(0.5, 3.5, 7.5, 12.5, 17.5,
                          25, 35, 45, 55, 75)
  )
  
  # Create age intervals and recode mortality levels
  plot_prep_data <- cemetery_df %>%
    mutate(
      Age_Interval = factor(case_when(
        Age < 2 ~ "0-1",
        Age >= 2 & Age < 6 ~ "2-5",
        Age >= 6 & Age < 10 ~ "6-9",
        Age >= 10 & Age < 15 ~ "10-14",
        Age >= 15 & Age < 20 ~ "15-19",
        Age >= 20 & Age < 30 ~ "20-29",
        Age >= 30 & Age < 40 ~ "30-39",
        Age >= 40 & Age < 50 ~ "40-49",
        Age >= 50 & Age < 60 ~ "50-59",
        Age >= 60 ~ "60+"
      ), levels = levels(age_lookup$Age_Interval)),
      mortality = factor(mortality, levels = c("CDW3", "CDW5", "CDW11", "CDW15", "CDW17", "CDW21")),
      mortality = recode(mortality,
                         "CDW3" = "CDW Level 3",
                         "CDW5" = "CDW Level 5",
                         "CDW11" = "CDW Level 11",
                         "CDW15" = "CDW Level 15",
                         "CDW17" = "CDW Level 17",
                         "CDW21" = "CDW Level 21")
    ) %>%
    # Group by specified variables and Age_Interval
    group_by(across(all_of(c(group_vars, "Age_Interval")))) %>%
    summarise(
      Lesion_Percent = sum(Lesion) / n() * 100,
      .groups = "drop"
    ) %>%
    # Join midpoints only where Age_Interval exists
    left_join(age_lookup, by = "Age_Interval")
  
  return(plot_prep_data)
}









# Function to read in lesion output data for each age in the living cohort. 
read_living_sweep <- function(root_output_directory, target_param, target_param_values) {
  sweep_results = list()
  
  # for each value in the parameter being swept
  for (param_value in target_param_values) {
    param_dir = file.path(root_output_directory, paste0(target_param,"=", param_value)) # identify the directory where the output for that scenario is stored
    rep_dirs = list.dirs(param_dir, recursive = FALSE, full.names = TRUE) # identify the file paths for all the iterations/runs of that scenario
    
    # extract the output .csv file from each run
    rep_outputs = lapply(rep_dirs, function(rep_dir) {
      output_file = file.path(rep_dir, "sim_survivors.csv")
      if (file.exists(output_file)) {
        return(read_csv(output_file))
      } else {
        print("file does not exist")
        return(NULL)
      }
    })
    
    # and save it as an entry in the sweep_results list, named with the target parameter value for this set of runs. 
    sweep_results[[paste0(target_param,"=",param_value)]] = rep_outputs
  }
  
  # return a list of lists: one for each value of the target parameter, containing a list of model output data frames from the output.csv files
  return(sweep_results)
}





read_in_living_sweep <- function(mortality_regime, lesion_rates, reps, rmr) {
  params <- get_default_params()
  params[["mortality_regime"]] <- mortality_regime
  params[["relative_mortality_risk"]] <- rmr
  
  out_dir <- generate_output_directory(params)
  sweep_data <- read_living_sweep(
    root_output_directory = out_dir,
    target_param = "lesion_formation_rate",
    target_param_values = lesion_rates
  )
  
  sweep_df <- data_to_data_frame(sweep_data, target_param_values = lesion_rates)
  
  # Annotate with mortality regime name for downstream grouping
  sweep_df$mortality <- paste0("CDW", regmatches(mortality_regime$name, gregexpr("[0-9]+", mortality_regime$name))[[1]])
  
  return(sweep_df)
}







